---
title: Scala 3 for Scala Haters
description: >-
  A talk directed toward the skeptics in my company, hoping to convince them of
  the merits of the improvements in Scala 3.
optimized_image: /talks/assets/header-images/scala.png
category: slides
tags:
  - Scala
  - Architalk
duration: 15
---
				<section>
                    <h3>Scala 3 for Scala Haters</h3>
                    <p>Karl Bielefeldt</p>
                </section>
                <section>
                <section>
                  <h3>The syntax is too busy</h3>
                </section>
                <section>
                  <pre><code data-trim data-noescape class="scala">
object Main {
  def main(args: Array[String]): Unit = {
    val xs = List(-2, -1, 0, 1, 2)
    val ys = List(3, 4, 5, 6, 7)

    val result = for {
      x <- xs
      y <- ys
    } yield if (x > 0) x else y

    result.foreach(println)
  }
}</code></pre>
                </section>
                <section>
                  <pre><code data-trim data-noescape class="scala">
  @main def main =
    val xs = List(-2, -1, 0, 1, 2)
    val ys = List(3, 4, 5, 6, 7)

    val result = for
      x <- xs
      y <- ys
    yield if x > 0 then x else y

    result.foreach(println)</code></pre>
                </section>
                </section>
                <section>
                <section>
                  <pre><code data-trim data-noescape class="scala">
                  TypeIActuallyWant with Product with Serializable</code></pre>
                </section>
                <section>
                  <pre><code data-trim data-noescape class="scala">
                  TypeIActuallyWant</code></pre>
                  <aside class="notes">
                    Thanks to transparent traits, these extra traits can be
                    suppressed during type inference, removing mental clutter.
                  </aside>
                </section>
                </section>
                <section>
                <section>
                  <h3>Nulls can't be checked at compile time</h3>
                </section>
                <section>
<pre><code data-trim data-noescape class="scala">
-- [E007] Type Mismatch Error: Main.scala:2:23
2 |  val string: String = null
  |                       ^^^^
  |                       Found:    Null
  |                       Required: String</code></pre>
                </section>
                </section>
                <section>
                <section>
                  <h3>It doesn't make sense to check for equality between different types</h3>
                </section>
                <section>
<pre><code data-trim data-noescape class="scala">
-- Error: Main.scala:2:2
2 |  "string" == 42
  |  ^^^^^^^^^^^^^^
  |  Values of types String and Int cannot be compared
  |  with == or !=</code></pre>
                </section>
                </section>
                <section>
                <section>
                  <h3>Infix operators are inconsistent</h3>
                </section>
                <section>
<pre><code data-trim data-noescape class="scala">
-- Error: Main.scala:6:7
6 |  list combine other
  |       ^^^^^^^
  |Alphanumeric method combine is not declared `infix`;
  |it should not be used as infix operator.  The operation
  |can be rewritten automatically to `combine` under
  | -deprecation -rewrite. Or rewrite to method syntax
  |.combine(...) manually.</code></pre>
                </section>
                </section>
                <section>
                <section>
                  <h3>Why do I have to use 'new' sometimes and not other times?</h3>
                </section>
                <section>
<pre><code data-trim data-noescape class="scala">
class MyClass(arg: Int)

// In Scala 2, this gives error: not found: value MyClass
// Works fine in Scala 3
MyClass(1)</code></pre>
                </section>
                </section>
                <section>
                <section>
                  <h3>Extension methods are confusing</h3>
                </section>
                <section>
<pre><code data-trim data-noescape class="scala">
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2</code></pre>
                </section>
                </section>
                <section>
                <section>
                  <h3>This is going to be another Python 2 -> 3 incompatibility fiasco</h3>
                </section>
                <section>
                  <ul>
                    <li class="fragment">Always been compatible with Java</li>
                    <li class="fragment">Can use 3.0 libraries from 2.13 code</li>
                    <li class="fragment">Can use 2.13 libraries (except macros) from 3.0 code</li>
                    <li class="fragment">3.0 published libraries are discouraged from depending on 2.13 libraries</li>
                    <li class="fragment">The 2.13 standard library is the official 3.0 standard library</li>
                  </ul>
                </section>
                <section>
                  <ul>
                    <li class="fragment">Many new features are opt-in (-Yexplicit-nulls, -Ysafe-init, -language:strictEquality)</li>
                    <li class="fragment">Many removed features are only deprecated until 3.1+ (-source:future)</li>
                    <li class="fragment">-explain and -explain-types</li>
                    <li class="fragment">2.13 compiler supports -Xsource:3 to start migration</li>
                    <li class="fragment">3.0 compiler has <a href="https://docs.scala-lang.org/scala3/guides/migration/tooling-migration-mode.html">Migration mode with rewrite</a></li>
                    <li class="fragment"><a href="https://docs.scala-lang.org/scala3/guides/migration/compatibility-intro.html">Migration Guide</a></li>
                  </ul>
                </section>
                </section>
                <section>
                <section>
                  <h3>Many nice things for the Scala lovers</h3>
                </section>
                <section>
                  <ul>
                    <li class="fragment">Intersection types</li>
                    <li class="fragment">Union types</li>
                    <li class="fragment">Type lambdas</li>
                    <li class="fragment">Match types</li>
                    <li class="fragment">Better enums</li>
                    <li class="fragment">Easier type classes</li>
                    <li class="fragment">Better conversions</li>
                    <li class="fragment">Better macros</li>
                    <li class="fragment">Performance improvements such as opaque types, inline, and @threadUnsafe</li>
                  </ul>
                </section>
                </section>
                <section>
                  <h2>Questions?</h2>
                  <a href="https://dotty.epfl.ch/docs/">https://dotty.epfl.ch/docs/</a>
                </section>
